<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内存搜索</title>
    <url>/2023/05/12/%E5%86%85%E5%AD%98%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="什么是内存搜索？"><a href="#什么是内存搜索？" class="headerlink" title="什么是内存搜索？"></a>什么是内存搜索？</h2><p>查找指定内存区段是否存在指定的值。</p>
<h2 id="内存搜索原理是啥？"><a href="#内存搜索原理是啥？" class="headerlink" title="内存搜索原理是啥？"></a>内存搜索原理是啥？</h2><p>从目标内存区段起始地址到内存区段结束位置去判断其中是否有满足我们条件的值，有则搜索到了目标地址。</p>
<h2 id="内存搜索的用途是什么？"><a href="#内存搜索的用途是什么？" class="headerlink" title="内存搜索的用途是什么？"></a>内存搜索的用途是什么？</h2><p>1.恶意程序特征提取；</p>
<p>2.特殊变量获取；</p>
<p>3.获取未公开函数地址；</p>
<p>4.and so on.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>获取Windows 7 x86的PspCidTable值：</p>
<p>通过windbg我们可以使用 <code>dd PspCidTable</code>命令获取到全局句柄表相关结构<code>HANDLE_TABLE</code>的地址，但是我们写 代码的过程中却没办法通过这个命令拿到PspCidTable的值，所以我们有一个方法就是通过字节特征码去查找到这个值，通过实验发现在<code>PsLookupProcessByProcessId</code>这个函数通过进程id查找进程的eprocess时使用到了这个PspCidTable,那我们就可以通过在驱动加载的时候去查找这个函数地址引用那块数据，从而便可以找到我们的PspCidTable了。</p>
<p>先看看PsLookupProcessByProcessId函数的特征：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PAGE:006696E9                                                 var_C= dword ptr -0Ch</span><br><span class="line">PAGE:006696E9                                                 var_8= dword ptr -8</span><br><span class="line">PAGE:006696E9                                                 var_4= dword ptr -4</span><br><span class="line">PAGE:006696E9                                                 ProcessId= dword ptr  8</span><br><span class="line">PAGE:006696E9                                                 Process= dword ptr  0Ch</span><br><span class="line">PAGE:006696E9</span><br><span class="line">PAGE:006696E9 8B FF                                           mov     edi, edi</span><br><span class="line">PAGE:006696EB 55                                              push    ebp</span><br><span class="line">PAGE:006696EC 8B EC                                           mov     ebp, esp</span><br><span class="line">PAGE:006696EE 83 EC 0C                                        sub     esp, 0Ch</span><br><span class="line">PAGE:006696F1 53                                              push    ebx</span><br><span class="line">PAGE:006696F2 56                                              push    esi</span><br><span class="line">PAGE:006696F3 64 8B 35 24 01 00 00                            mov     esi, large fs:124h</span><br><span class="line">PAGE:006696FA 33 DB                                           xor     ebx, ebx</span><br><span class="line">PAGE:006696FC 66 FF 8E 84 00 00 00                            dec     word ptr [esi+84h]</span><br><span class="line">PAGE:00669703 57                                              push    edi</span><br><span class="line">PAGE:00669704 FF 75 08                                        push    [ebp+ProcessId]</span><br><span class="line">PAGE:00669707 8B 3D 94 DD 54 00                               mov     edi, _PspCidTable</span><br><span class="line">PAGE:0066970D E8 21 52 FE FF                                  call    _ExMapHandleToPointer@8         ; ExMapHandleToPointer(x,x)</span><br></pre></td></tr></table></figure></div>

<p>从上面可以看到 <code>mov edi, _PspCidTable</code>这个指令使用到了PspCidTable的值，但是这个值不是固定的，是运行时才能得到值的，所以咱们需要用相邻的字节特征来找到这个PspCidTable的值，那咱们就用call _ExMapHandleToPointer特征查找：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">E8 21 52 FE FF           call    _ExMapHandleToPointer@8</span><br></pre></td></tr></table></figure></div>

<p>当然我选用上面这段指令的特征没去确定有没有其他地方也调用了这段指令，但是我就是头铁我就要选它，你们也可以选则push edi上面那条指令，特征性相对来说比我选的这个强，好了，我以这个例子来说一下代码思路，也是暴力搜索思路：</p>
<p>1.获取PsLookupProcessByProcessId所在模块地址和模块大小，模块名为“ntkrnlpa.exe”，模块地址便是内存搜索起始地址，模块地址+模块大小便是搜索结束地址；</p>
<p>2.从搜索起始地址不停判断是否存在一块连续内存是符合我们特征的是的话就找到了，返回这个地址；</p>
<p>3.PspCidTable地址占4个字节，所以我们通过特征拿到的地址减去4个字节就得到了PspCidTable的地址了；</p>
<p><strong>奉上代码：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _RTL_PROCESS_MODULE_INFORMATION &#123;</span><br><span class="line">        HANDLE Section;                 // Not filled in</span><br><span class="line">        PVOID MappedBase;</span><br><span class="line">        PVOID ImageBase;</span><br><span class="line">        ULONG ImageSize;</span><br><span class="line">        ULONG Flags;</span><br><span class="line">        USHORT LoadOrderIndex;</span><br><span class="line">        USHORT InitOrderIndex;</span><br><span class="line">        USHORT LoadCount;</span><br><span class="line">        USHORT OffsetToFileName;</span><br><span class="line">        UCHAR  FullPathName[256];</span><br><span class="line">&#125; RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;</span><br><span class="line">typedef struct _RTL_PROCESS_MODULES &#123;</span><br><span class="line">        ULONG NumberOfModules;</span><br><span class="line">        RTL_PROCESS_MODULE_INFORMATION Modules[1];</span><br><span class="line">&#125; RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;</span><br><span class="line">typedef enum _SYSTEM_INFORMATION_CLASS &#123;</span><br><span class="line">        SystemBasicInformation,</span><br><span class="line">        SystemProcessorInformation,             // obsolete...delete</span><br><span class="line">        SystemPerformanceInformation,</span><br><span class="line">        SystemTimeOfDayInformation,</span><br><span class="line">        SystemPathInformation,</span><br><span class="line">        SystemProcessInformation,</span><br><span class="line">        SystemCallCountInformation,</span><br><span class="line">        SystemDeviceInformation,</span><br><span class="line">        SystemProcessorPerformanceInformation,</span><br><span class="line">        SystemFlagsInformation,</span><br><span class="line">        SystemCallTimeInformation,</span><br><span class="line">        SystemModuleInformation,</span><br><span class="line">        SystemLocksInformation,</span><br><span class="line">        SystemStackTraceInformation,</span><br><span class="line">        SystemPagedPoolInformation,</span><br><span class="line">        SystemNonPagedPoolInformation,</span><br><span class="line">        SystemHandleInformation,</span><br><span class="line">        SystemObjectInformation,</span><br><span class="line">        SystemPageFileInformation,</span><br><span class="line">        SystemVdmInstemulInformation,</span><br><span class="line">        SystemVdmBopInformation,</span><br><span class="line">        SystemFileCacheInformation,</span><br><span class="line">        SystemPoolTagInformation,</span><br><span class="line">        SystemInterruptInformation,</span><br><span class="line">        SystemDpcBehaviorInformation,</span><br><span class="line">        SystemFullMemoryInformation,</span><br><span class="line">        SystemLoadGdiDriverInformation,</span><br><span class="line">        SystemUnloadGdiDriverInformation,</span><br><span class="line">        SystemTimeAdjustmentInformation,</span><br><span class="line">        SystemSummaryMemoryInformation,</span><br><span class="line">        SystemMirrorMemoryInformation,</span><br><span class="line">        SystemPerformanceTraceInformation,</span><br><span class="line">        SystemObsolete0,</span><br><span class="line">        SystemExceptionInformation,</span><br><span class="line">        SystemCrashDumpStateInformation,</span><br><span class="line">        SystemKernelDebuggerInformation,</span><br><span class="line">        SystemContextSwitchInformation,</span><br><span class="line">        SystemRegistryQuotaInformation,</span><br><span class="line">        SystemExtendServiceTableInformation,</span><br><span class="line">        SystemPrioritySeperation,</span><br><span class="line">        SystemVerifierAddDriverInformation,</span><br><span class="line">        SystemVerifierRemoveDriverInformation,</span><br><span class="line">        SystemProcessorIdleInformation,</span><br><span class="line">        SystemLegacyDriverInformation,</span><br><span class="line">        SystemCurrentTimeZoneInformation,</span><br><span class="line">        SystemLookasideInformation,</span><br><span class="line">        SystemTimeSlipNotification,</span><br><span class="line">        SystemSessionCreate,</span><br><span class="line">        SystemSessionDetach,</span><br><span class="line">        SystemSessionInformation,</span><br><span class="line">        SystemRangeStartInformation,</span><br><span class="line">        SystemVerifierInformation,</span><br><span class="line">        SystemVerifierThunkExtend,</span><br><span class="line">        SystemSessionProcessInformation,</span><br><span class="line">        SystemLoadGdiDriverInSystemSpace,</span><br><span class="line">        SystemNumaProcessorMap,</span><br><span class="line">        SystemPrefetcherInformation,</span><br><span class="line">        SystemExtendedProcessInformation,</span><br><span class="line">        SystemRecommendedSharedDataAlignment,</span><br><span class="line">        SystemComPlusPackage,</span><br><span class="line">        SystemNumaAvailableMemory,</span><br><span class="line">        SystemProcessorPowerInformation,</span><br><span class="line">        SystemEmulationBasicInformation,</span><br><span class="line">        SystemEmulationProcessorInformation,</span><br><span class="line">        SystemExtendedHandleInformation,</span><br><span class="line">        SystemLostDelayedWriteInformation,</span><br><span class="line">        SystemBigPoolInformation,</span><br><span class="line">        SystemSessionPoolTagInformation,</span><br><span class="line">        SystemSessionMappedViewInformation,</span><br><span class="line">        SystemHotpatchInformation,</span><br><span class="line">        SystemObjectSecurityMode,</span><br><span class="line">        SystemWatchdogTimerHandler,</span><br><span class="line">        SystemWatchdogTimerInformation,</span><br><span class="line">        SystemLogicalProcessorInformation,</span><br><span class="line">        SystemWow64SharedInformation,</span><br><span class="line">        SystemRegisterFirmwareTableInformationHandler,</span><br><span class="line">        SystemFirmwareTableInformation,</span><br><span class="line">        SystemModuleInformationEx,</span><br><span class="line">        SystemVerifierTriageInformation,</span><br><span class="line">        SystemSuperfetchInformation,</span><br><span class="line">        SystemMemoryListInformation,</span><br><span class="line">        SystemFileCacheInformationEx,</span><br><span class="line">        MaxSystemInfoClass  // MaxSystemInfoClass should always be the last enum</span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line">NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation(</span><br><span class="line">        __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">        __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</span><br><span class="line">        __in ULONG SystemInformationLength,</span><br><span class="line">        __out_opt PULONG ReturnLength</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">ULONG_PTR GetKernelModuleBase(PUCHAR moduleName, PULONG pModuleSize) &#123;</span><br><span class="line">        RTL_PROCESS_MODULES SysModules = &#123; 0 &#125;;</span><br><span class="line">        PRTL_PROCESS_MODULES pModules = &amp;SysModules;</span><br><span class="line">        ULONG SystemInformationLength = 0;</span><br><span class="line">        //查询系统中所有内核模块，底层也是遍历链表</span><br><span class="line">        NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, pModules, sizeof(RTL_PROCESS_MODULES), &amp;SystemInformationLength);</span><br><span class="line">        if (status == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">                pModules = ExAllocatePool(NonPagedPool, SystemInformationLength + sizeof(RTL_PROCESS_MODULES));</span><br><span class="line">                RtlZeroMemory(pModules, SystemInformationLength + sizeof(RTL_PROCESS_MODULES));</span><br><span class="line">                status = ZwQuerySystemInformation(SystemModuleInformation, pModules, SystemInformationLength + sizeof(RTL_PROCESS_MODULES), &amp;SystemInformationLength);</span><br><span class="line">                if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">                        ExFreePool(pModules);</span><br><span class="line">                        return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!strcmp(&quot;ntkrnlpa.exe&quot;, moduleName)) &#123;</span><br><span class="line">                ULONG_PTR ret = pModules-&gt;Modules[0].ImageBase;</span><br><span class="line">                *pModuleSize = pModules-&gt;Modules[0].ImageSize;</span><br><span class="line">                if (SystemInformationLength) &#123;</span><br><span class="line">                        ExFreePool(pModules);</span><br><span class="line">                &#125;</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ULONG i = 0; i &lt; pModules-&gt;NumberOfModules; i++) &#123;</span><br><span class="line">                if (strstr(pModules-&gt;Modules[i].FullPathName, moduleName)) &#123;</span><br><span class="line">                        ULONG_PTR ret = pModules-&gt;Modules[i].ImageBase;</span><br><span class="line">                        *pModuleSize = pModules-&gt;Modules[0].ImageSize;</span><br><span class="line">                        if (SystemInformationLength) &#123;</span><br><span class="line">                                ExFreePool(pModules);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //返回模块地址</span><br><span class="line">                        return ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (SystemInformationLength) &#123;</span><br><span class="line">                ExFreePool(pModules);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID SearchSpecialCode(PVOID pSearchBeginAddr, ULONG ulSearchLength, PUCHAR pSpecialCode, ULONG ulSpecialCodeLength)</span><br><span class="line">&#123;</span><br><span class="line">        PVOID pDestAddr = NULL;</span><br><span class="line">        PUCHAR pBeginAddr = (PUCHAR)pSearchBeginAddr;</span><br><span class="line">        PUCHAR pEndAddr = pBeginAddr + ulSearchLength;</span><br><span class="line">        PUCHAR i = NULL;</span><br><span class="line">        ULONG j = 0;</span><br><span class="line"></span><br><span class="line">        for (i = pBeginAddr; i &lt;= pEndAddr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                // 遍历特征码</span><br><span class="line">                for (j = 0; j &lt; ulSpecialCodeLength; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        // 判断地址是否有效</span><br><span class="line">                        if (FALSE == MmIsAddressValid((PVOID)(i + j)))</span><br><span class="line">                        &#123;</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 匹配特征码</span><br><span class="line">                        if (*(PUCHAR)(i + j) != pSpecialCode[j])</span><br><span class="line">                        &#123;</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 匹配成功</span><br><span class="line">                if (j &gt;= ulSpecialCodeLength)</span><br><span class="line">                &#123;</span><br><span class="line">                        pDestAddr = (PVOID)i;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pDestAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID UnloadDriver(PDRIVER_OBJECT pDriver)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath)</span><br><span class="line">&#123;</span><br><span class="line">        ULONG sizeofcode = 0;</span><br><span class="line">        ULONG_PTR baseaddr = GetKernelModuleBase(&quot;ntkrnlpa.exe&quot;, &amp;sizeofcode);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:base地址为:%p\n&quot;, baseaddr);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:base长度为:%p\n&quot;, sizeofcode);</span><br><span class="line">        UCHAR specode[4] = &#123; 0xE8, 0x21, 0x52, 0xFE,0xFF &#125;;</span><br><span class="line">        ULONG_PTR codeaddr = SearchSpecialCode(baseaddr, sizeofcode, specode,5);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:找到的代码地址为:%p\n&quot;, codeaddr);</span><br><span class="line">        ULONG_PTR uGetPspGet = (*(PULONG)((PUCHAR)codeaddr - 6 + 2));</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:全局句柄表的地址为:%p\n&quot;, uGetPspGet);</span><br><span class="line">        pDriver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">        return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
</search>
