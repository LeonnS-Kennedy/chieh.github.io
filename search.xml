<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内存搜索</title>
    <url>/2023/05/12/%E5%86%85%E5%AD%98%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="什么是内存搜索？"><a href="#什么是内存搜索？" class="headerlink" title="什么是内存搜索？"></a>什么是内存搜索？</h2><p>查找指定内存区段是否存在指定的值。</p>
<h2 id="内存搜索原理是啥？"><a href="#内存搜索原理是啥？" class="headerlink" title="内存搜索原理是啥？"></a>内存搜索原理是啥？</h2><p>从目标内存区段起始地址到内存区段结束位置去判断其中是否有满足我们条件的值，有则搜索到了目标地址。</p>
<h2 id="内存搜索的用途是什么？"><a href="#内存搜索的用途是什么？" class="headerlink" title="内存搜索的用途是什么？"></a>内存搜索的用途是什么？</h2><p>1.恶意程序特征提取；</p>
<p>2.特殊变量获取；</p>
<p>3.获取未公开函数地址；</p>
<p>4.and so on.</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>获取Windows 7 x86的PspCidTable值：</p>
<p>通过windbg我们可以使用 <code>dd PspCidTable</code>命令获取到全局句柄表相关结构<code>HANDLE_TABLE</code>的地址，但是我们写 代码的过程中却没办法通过这个命令拿到PspCidTable的值，所以我们有一个方法就是通过字节特征码去查找到这个值，通过实验发现在<code>PsLookupProcessByProcessId</code>这个函数通过进程id查找进程的eprocess时使用到了这个PspCidTable,那我们就可以通过在驱动加载的时候去查找这个函数地址引用那块数据，从而便可以找到我们的PspCidTable了。</p>
<p>先看看PsLookupProcessByProcessId函数的特征：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PAGE:006696E9                                                 var_C= dword ptr -0Ch</span><br><span class="line">PAGE:006696E9                                                 var_8= dword ptr -8</span><br><span class="line">PAGE:006696E9                                                 var_4= dword ptr -4</span><br><span class="line">PAGE:006696E9                                                 ProcessId= dword ptr  8</span><br><span class="line">PAGE:006696E9                                                 Process= dword ptr  0Ch</span><br><span class="line">PAGE:006696E9</span><br><span class="line">PAGE:006696E9 8B FF                                           mov     edi, edi</span><br><span class="line">PAGE:006696EB 55                                              push    ebp</span><br><span class="line">PAGE:006696EC 8B EC                                           mov     ebp, esp</span><br><span class="line">PAGE:006696EE 83 EC 0C                                        sub     esp, 0Ch</span><br><span class="line">PAGE:006696F1 53                                              push    ebx</span><br><span class="line">PAGE:006696F2 56                                              push    esi</span><br><span class="line">PAGE:006696F3 64 8B 35 24 01 00 00                            mov     esi, large fs:124h</span><br><span class="line">PAGE:006696FA 33 DB                                           xor     ebx, ebx</span><br><span class="line">PAGE:006696FC 66 FF 8E 84 00 00 00                            dec     word ptr [esi+84h]</span><br><span class="line">PAGE:00669703 57                                              push    edi</span><br><span class="line">PAGE:00669704 FF 75 08                                        push    [ebp+ProcessId]</span><br><span class="line">PAGE:00669707 8B 3D 94 DD 54 00                               mov     edi, _PspCidTable</span><br><span class="line">PAGE:0066970D E8 21 52 FE FF                                  call    _ExMapHandleToPointer@8         ; ExMapHandleToPointer(x,x)</span><br></pre></td></tr></table></figure></div>

<p>从上面可以看到 <code>mov edi, _PspCidTable</code>这个指令使用到了PspCidTable的值，但是这个值不是固定的，是运行时才能得到值的，所以咱们需要用相邻的字节特征来找到这个PspCidTable的值，那咱们就用call _ExMapHandleToPointer特征查找：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">E8 21 52 FE FF           call    _ExMapHandleToPointer@8</span><br></pre></td></tr></table></figure></div>

<p>当然我选用上面这段指令的特征没去确定有没有其他地方也调用了这段指令，但是我就是头铁我就要选它，你们也可以选则push edi上面那条指令，特征性相对来说比我选的这个强，好了，我以这个例子来说一下代码思路，也是暴力搜索思路：</p>
<p>1.获取PsLookupProcessByProcessId所在模块地址和模块大小，模块名为“ntkrnlpa.exe”，模块地址便是内存搜索起始地址，模块地址+模块大小便是搜索结束地址；</p>
<p>2.从搜索起始地址不停判断是否存在一块连续内存是符合我们特征的是的话就找到了，返回这个地址；</p>
<p>3.PspCidTable地址占4个字节，所以我们通过特征拿到的地址减去4个字节就得到了PspCidTable的地址了；</p>
<p><strong>奉上代码：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct _RTL_PROCESS_MODULE_INFORMATION &#123;</span><br><span class="line">        HANDLE Section;                 // Not filled in</span><br><span class="line">        PVOID MappedBase;</span><br><span class="line">        PVOID ImageBase;</span><br><span class="line">        ULONG ImageSize;</span><br><span class="line">        ULONG Flags;</span><br><span class="line">        USHORT LoadOrderIndex;</span><br><span class="line">        USHORT InitOrderIndex;</span><br><span class="line">        USHORT LoadCount;</span><br><span class="line">        USHORT OffsetToFileName;</span><br><span class="line">        UCHAR  FullPathName[256];</span><br><span class="line">&#125; RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;</span><br><span class="line">typedef struct _RTL_PROCESS_MODULES &#123;</span><br><span class="line">        ULONG NumberOfModules;</span><br><span class="line">        RTL_PROCESS_MODULE_INFORMATION Modules[1];</span><br><span class="line">&#125; RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;</span><br><span class="line">typedef enum _SYSTEM_INFORMATION_CLASS &#123;</span><br><span class="line">        SystemBasicInformation,</span><br><span class="line">        SystemProcessorInformation,             // obsolete...delete</span><br><span class="line">        SystemPerformanceInformation,</span><br><span class="line">        SystemTimeOfDayInformation,</span><br><span class="line">        SystemPathInformation,</span><br><span class="line">        SystemProcessInformation,</span><br><span class="line">        SystemCallCountInformation,</span><br><span class="line">        SystemDeviceInformation,</span><br><span class="line">        SystemProcessorPerformanceInformation,</span><br><span class="line">        SystemFlagsInformation,</span><br><span class="line">        SystemCallTimeInformation,</span><br><span class="line">        SystemModuleInformation,</span><br><span class="line">        SystemLocksInformation,</span><br><span class="line">        SystemStackTraceInformation,</span><br><span class="line">        SystemPagedPoolInformation,</span><br><span class="line">        SystemNonPagedPoolInformation,</span><br><span class="line">        SystemHandleInformation,</span><br><span class="line">        SystemObjectInformation,</span><br><span class="line">        SystemPageFileInformation,</span><br><span class="line">        SystemVdmInstemulInformation,</span><br><span class="line">        SystemVdmBopInformation,</span><br><span class="line">        SystemFileCacheInformation,</span><br><span class="line">        SystemPoolTagInformation,</span><br><span class="line">        SystemInterruptInformation,</span><br><span class="line">        SystemDpcBehaviorInformation,</span><br><span class="line">        SystemFullMemoryInformation,</span><br><span class="line">        SystemLoadGdiDriverInformation,</span><br><span class="line">        SystemUnloadGdiDriverInformation,</span><br><span class="line">        SystemTimeAdjustmentInformation,</span><br><span class="line">        SystemSummaryMemoryInformation,</span><br><span class="line">        SystemMirrorMemoryInformation,</span><br><span class="line">        SystemPerformanceTraceInformation,</span><br><span class="line">        SystemObsolete0,</span><br><span class="line">        SystemExceptionInformation,</span><br><span class="line">        SystemCrashDumpStateInformation,</span><br><span class="line">        SystemKernelDebuggerInformation,</span><br><span class="line">        SystemContextSwitchInformation,</span><br><span class="line">        SystemRegistryQuotaInformation,</span><br><span class="line">        SystemExtendServiceTableInformation,</span><br><span class="line">        SystemPrioritySeperation,</span><br><span class="line">        SystemVerifierAddDriverInformation,</span><br><span class="line">        SystemVerifierRemoveDriverInformation,</span><br><span class="line">        SystemProcessorIdleInformation,</span><br><span class="line">        SystemLegacyDriverInformation,</span><br><span class="line">        SystemCurrentTimeZoneInformation,</span><br><span class="line">        SystemLookasideInformation,</span><br><span class="line">        SystemTimeSlipNotification,</span><br><span class="line">        SystemSessionCreate,</span><br><span class="line">        SystemSessionDetach,</span><br><span class="line">        SystemSessionInformation,</span><br><span class="line">        SystemRangeStartInformation,</span><br><span class="line">        SystemVerifierInformation,</span><br><span class="line">        SystemVerifierThunkExtend,</span><br><span class="line">        SystemSessionProcessInformation,</span><br><span class="line">        SystemLoadGdiDriverInSystemSpace,</span><br><span class="line">        SystemNumaProcessorMap,</span><br><span class="line">        SystemPrefetcherInformation,</span><br><span class="line">        SystemExtendedProcessInformation,</span><br><span class="line">        SystemRecommendedSharedDataAlignment,</span><br><span class="line">        SystemComPlusPackage,</span><br><span class="line">        SystemNumaAvailableMemory,</span><br><span class="line">        SystemProcessorPowerInformation,</span><br><span class="line">        SystemEmulationBasicInformation,</span><br><span class="line">        SystemEmulationProcessorInformation,</span><br><span class="line">        SystemExtendedHandleInformation,</span><br><span class="line">        SystemLostDelayedWriteInformation,</span><br><span class="line">        SystemBigPoolInformation,</span><br><span class="line">        SystemSessionPoolTagInformation,</span><br><span class="line">        SystemSessionMappedViewInformation,</span><br><span class="line">        SystemHotpatchInformation,</span><br><span class="line">        SystemObjectSecurityMode,</span><br><span class="line">        SystemWatchdogTimerHandler,</span><br><span class="line">        SystemWatchdogTimerInformation,</span><br><span class="line">        SystemLogicalProcessorInformation,</span><br><span class="line">        SystemWow64SharedInformation,</span><br><span class="line">        SystemRegisterFirmwareTableInformationHandler,</span><br><span class="line">        SystemFirmwareTableInformation,</span><br><span class="line">        SystemModuleInformationEx,</span><br><span class="line">        SystemVerifierTriageInformation,</span><br><span class="line">        SystemSuperfetchInformation,</span><br><span class="line">        SystemMemoryListInformation,</span><br><span class="line">        SystemFileCacheInformationEx,</span><br><span class="line">        MaxSystemInfoClass  // MaxSystemInfoClass should always be the last enum</span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br><span class="line"></span><br><span class="line">NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation(</span><br><span class="line">        __in SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">        __out_bcount_opt(SystemInformationLength) PVOID SystemInformation,</span><br><span class="line">        __in ULONG SystemInformationLength,</span><br><span class="line">        __out_opt PULONG ReturnLength</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">ULONG_PTR GetKernelModuleBase(PUCHAR moduleName, PULONG pModuleSize) &#123;</span><br><span class="line">        RTL_PROCESS_MODULES SysModules = &#123; 0 &#125;;</span><br><span class="line">        PRTL_PROCESS_MODULES pModules = &amp;SysModules;</span><br><span class="line">        ULONG SystemInformationLength = 0;</span><br><span class="line">        //查询系统中所有内核模块，底层也是遍历链表</span><br><span class="line">        NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, pModules, sizeof(RTL_PROCESS_MODULES), &amp;SystemInformationLength);</span><br><span class="line">        if (status == STATUS_INFO_LENGTH_MISMATCH) &#123;</span><br><span class="line">                pModules = ExAllocatePool(NonPagedPool, SystemInformationLength + sizeof(RTL_PROCESS_MODULES));</span><br><span class="line">                RtlZeroMemory(pModules, SystemInformationLength + sizeof(RTL_PROCESS_MODULES));</span><br><span class="line">                status = ZwQuerySystemInformation(SystemModuleInformation, pModules, SystemInformationLength + sizeof(RTL_PROCESS_MODULES), &amp;SystemInformationLength);</span><br><span class="line">                if (!NT_SUCCESS(status)) &#123;</span><br><span class="line">                        ExFreePool(pModules);</span><br><span class="line">                        return 0;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!strcmp(&quot;ntkrnlpa.exe&quot;, moduleName)) &#123;</span><br><span class="line">                ULONG_PTR ret = pModules-&gt;Modules[0].ImageBase;</span><br><span class="line">                *pModuleSize = pModules-&gt;Modules[0].ImageSize;</span><br><span class="line">                if (SystemInformationLength) &#123;</span><br><span class="line">                        ExFreePool(pModules);</span><br><span class="line">                &#125;</span><br><span class="line">                return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ULONG i = 0; i &lt; pModules-&gt;NumberOfModules; i++) &#123;</span><br><span class="line">                if (strstr(pModules-&gt;Modules[i].FullPathName, moduleName)) &#123;</span><br><span class="line">                        ULONG_PTR ret = pModules-&gt;Modules[i].ImageBase;</span><br><span class="line">                        *pModuleSize = pModules-&gt;Modules[0].ImageSize;</span><br><span class="line">                        if (SystemInformationLength) &#123;</span><br><span class="line">                                ExFreePool(pModules);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //返回模块地址</span><br><span class="line">                        return ret;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (SystemInformationLength) &#123;</span><br><span class="line">                ExFreePool(pModules);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID SearchSpecialCode(PVOID pSearchBeginAddr, ULONG ulSearchLength, PUCHAR pSpecialCode, ULONG ulSpecialCodeLength)</span><br><span class="line">&#123;</span><br><span class="line">        PVOID pDestAddr = NULL;</span><br><span class="line">        PUCHAR pBeginAddr = (PUCHAR)pSearchBeginAddr;</span><br><span class="line">        PUCHAR pEndAddr = pBeginAddr + ulSearchLength;</span><br><span class="line">        PUCHAR i = NULL;</span><br><span class="line">        ULONG j = 0;</span><br><span class="line"></span><br><span class="line">        for (i = pBeginAddr; i &lt;= pEndAddr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                // 遍历特征码</span><br><span class="line">                for (j = 0; j &lt; ulSpecialCodeLength; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        // 判断地址是否有效</span><br><span class="line">                        if (FALSE == MmIsAddressValid((PVOID)(i + j)))</span><br><span class="line">                        &#123;</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 匹配特征码</span><br><span class="line">                        if (*(PUCHAR)(i + j) != pSpecialCode[j])</span><br><span class="line">                        &#123;</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 匹配成功</span><br><span class="line">                if (j &gt;= ulSpecialCodeLength)</span><br><span class="line">                &#123;</span><br><span class="line">                        pDestAddr = (PVOID)i;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pDestAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID UnloadDriver(PDRIVER_OBJECT pDriver)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath)</span><br><span class="line">&#123;</span><br><span class="line">        ULONG sizeofcode = 0;</span><br><span class="line">        ULONG_PTR baseaddr = GetKernelModuleBase(&quot;ntkrnlpa.exe&quot;, &amp;sizeofcode);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:base地址为:%p\n&quot;, baseaddr);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:base长度为:%p\n&quot;, sizeofcode);</span><br><span class="line">        UCHAR specode[4] = &#123; 0xE8, 0x21, 0x52, 0xFE,0xFF &#125;;</span><br><span class="line">        ULONG_PTR codeaddr = SearchSpecialCode(baseaddr, sizeofcode, specode,5);</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:找到的代码地址为:%p\n&quot;, codeaddr);</span><br><span class="line">        ULONG_PTR uGetPspGet = (*(PULONG)((PUCHAR)codeaddr - 6 + 2));</span><br><span class="line">        DbgPrintEx(77, 0, &quot;[db]:全局句柄表的地址为:%p\n&quot;, uGetPspGet);</span><br><span class="line">        pDriver-&gt;DriverUnload = UnloadDriver;</span><br><span class="line">        return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
  </entry>
  <entry>
    <title>GPT网站问答流程逆向和Python复现</title>
    <url>/2023/05/12/GPT%E7%BD%91%E7%AB%99%E9%97%AE%E7%AD%94%E6%B5%81%E7%A8%8B%E9%80%86%E5%90%91%E5%92%8CPython%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>F12打开开发者工具，输入问题，点击发送，查看Network记录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NsS41.png"
                     
                ></p>
<p>发现有两条请求，第一条是普通的XMLHttpRequest，第二条是一个stream流，联想到网站显示回答时通常一个字一个字逐步显示，回答应该就是通过stream流传输的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NsC36.png"
                     
                ></p>
<p>查看该流，果然将答案拆开传输，这就是我们的目标请求了，观察stream流请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NyUdH.png"
                     
                ></p>
<p>这样的不带参数的get请求如何使服务端确定问题是什么呢，猜测网站对cookie进行了操作，查看两条请求的cookie：</p>
<p>1.submit的cookie</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NsPgK.png"
                     
                ></p>
<p>2.stream的cookie</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NrjHJ.png"
                     
                ></p>
<p>发现在submit后，响应体设置了新的cookie：<code>session</code>，因此只要获取该session的cookie值，就可以编写请求索取GPT的回答。为了获取session值，则需要先发送submit请求，观察该请求，发现这是一个POST请求，通过Payload的方式上传数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9Ns99x.png"
                     
                ></p>
<p>这里有两个参数：<code>his</code>和<code>prompt</code>，prompt很好理解，就是发送的问题，此处进行了加密处理，his是一个列表，大概率是历史记录（该GPT有根据上文回答问题的功能），那么我们先分析prompt的生成</p>
<p>观察到submit请求的Initiator是main.js，直接到该文件中搜索”prompt”，发现并没有结果</p>
<p>观察main.js，发现是加密混淆过的，其中有大量的十六进制字符串和一堆毫无意义的偏移和函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s1.ax1x.com/2023/05/05/p9NrxE9.png"
                     
                ></p>
<p>把文件送入解密网站，把代码进行解码，再次搜索”prompt”</p>
<p>成功定位到了位置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var W = input_value;  // 输入的问题字符串</span><br><span class="line">document[n(zZ.Xb, 0x145, zZ.js, zZ.XR) + &#x27;Ele&#x27; + n(0x1de, 0x30e, &#x27;z$N#&#x27;, 0x1e2) + &#x27;tBy&#x27; + &#x27;Id&#x27;](I[d(zZ.Xm, zZ.XV, 0x25, -zZ.XM) + &#x27;kc&#x27;])[d(zZ.XO, zZ.XH, 0x45, 0x154) + &#x27;ue&#x27;] = &#x27;&#x27;;</span><br><span class="line">var y = I[d(zZ.Xt, zZ.XQ, -0x147, zZ.Xe) + &#x27;SF&#x27;](P, W);</span><br><span class="line">D[n(0x1b5, zZ.um, &#x27;YS3C&#x27;, 0x114) + &#x27;d&#x27;](JSON[d(&#x27;5l3F&#x27;, -0xef, -zZ.XT, -0x20f) + n(zZ.Xl, 0x174, &#x27;jHS6&#x27;, -zZ.Xs) + n(0xea, zZ.XZ, zZ.Xa, -zZ.XG)](&#123;</span><br><span class="line">    &#x27;prompt&#x27;: y,</span><br><span class="line">    &#x27;his&#x27;: window[n(zZ.XJ, -0x2, &#x27;2Qf[&#x27;, 0x74) + d(&#x27;[qgO&#x27;, -zZ.XF, -zZ.Xr, -zZ.jz) + &#x27;ys&#x27;][n(zZ.Xc, 0x154, &#x27;i2$#&#x27;, 0x1bc) + d(zZ.Xv, -zZ.XE, -zZ.Xh, -0x2ad)] &lt;= 0x1d * 0x76 + 0x18f2 + -0xcc5 * 0x3 || !document[n(0x1e, -zZ.Xn, &#x27;xt$S&#x27;, zZ.Xd) + &#x27;Ele&#x27; + n(0x8, -0x3e, &#x27;5l3F&#x27;, zZ.XK) + n(zZ.XL, -0x57, &#x27;8UZA&#x27;, zZ.S0) + &#x27;Id&#x27;](I[d(zZ.S1, -0x1cb, -0x311, -0x7f) + &#x27;pZ&#x27;])[n(0x1fe, zZ.S2, &#x27;2Qf[&#x27;, zZ.S3) + &#x27;cke&#x27; + &#x27;d&#x27;] ? [] : window[d(zZ.S4, -0x22a, -zZ.S5, -zZ.S6) + n(zZ.ja, -zZ.S7, zZ.u0, 0x18c) + &#x27;ys&#x27;]</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></div>

<p>整个代码都被混淆了，但依稀还能见到一些影子，比如第二行中能拼凑出熟悉的<code>ElementById</code></p>
<p>这里能发现，prompt值就是y，而his的值则是先比较了<code>historyCheck</code>的值，如果选择了则为列表值，未选择则为空列表<code>[]</code></p>
<p>重点在y的计算上，此处打上断点，重新发送，定位到该函数的位置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;\x5a\x41\x7a\x53\x46&#x27;: function(x, U) &#123;</span><br><span class="line">    return x(U);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>

<p>即:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var y = P(W);</span><br></pre></td></tr></table></figure></div>

<p>跳转到函数P：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function P(x) &#123;</span><br><span class="line">    var zf = &#123;</span><br><span class="line">        I: 0x23,</span><br><span class="line">        P: 0x159</span><br><span class="line">    &#125;;</span><br><span class="line">    const U = CryptoJS[K(zw.I, zw.P, zw.D, 0x634)][K(zw.W, zw.y, zw.x, 0x5f7) + &#x27;8&#x27;][L(-0x172, -0x1a6, zw.U, -0x1cd) + &#x27;se&#x27;](I[K(0x4f8, zw.p, zw.f, 0x348) + &#x27;DP&#x27;]);</span><br><span class="line"></span><br><span class="line">    function K(I, P, D, W) &#123;</span><br><span class="line">        return d(P, I - zp.I, D - zp.P, W - zp.D);</span><br><span class="line">    &#125;</span><br><span class="line">    const p = CryptoJS[L(zw.w, -zw.C, &#x27;Oh0s&#x27;, -0x88)][K(0x57a, &#x27;8Xtv&#x27;, 0x689, 0x522) + &#x27;8&#x27;][L(-0x3a, -0xf1, &#x27;TyCN&#x27;, zw.k) + &#x27;se&#x27;](I[L(-0xec, 0x78, zw.N, -zw.B) + &#x27;gQ&#x27;]);</span><br><span class="line">    let f = CryptoJS[L(-0x29a, -zw.q, &#x27;!mzD&#x27;, -zw.Y)][K(zw.A, zw.zC, zw.zk, zw.zN) + &#x27;ryp&#x27; + &#x27;t&#x27;](x, U, &#123;</span><br><span class="line">        &#x27;iv&#x27;: p,</span><br><span class="line">        &#x27;mode&#x27;: CryptoJS[K(zw.zB, zw.zq, zw.zY, 0x208) + &#x27;e&#x27;][K(zw.zA, &#x27;ui19&#x27;, zw.zb, zw.zR)],</span><br><span class="line">        &#x27;padding&#x27;: CryptoJS[K(zw.zm, zw.zV, 0x600, 0x58c)][L(-zw.zM, -zw.zO, zw.zH, -0x11) + K(0x4b5, zw.zt, 0x65a, zw.zQ) + L(zw.ze, -zw.zT, zw.zl, -zw.zs) + &#x27;ng&#x27;]</span><br><span class="line">    &#125;)[&#x27;toS&#x27; + L(zw.zZ, 0x52, &#x27;AO11&#x27;, -zw.za) + &#x27;ng&#x27;]();</span><br><span class="line">    console[K(zw.zG, zw.zJ, 0x3ed, 0x48f)](f);</span><br><span class="line"></span><br><span class="line">    function L(I, P, D, W) &#123;</span><br><span class="line">        return d(D, W - -zf.I, D - 0x2b, W - zf.P);</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看到CryptoJS关键字就知道，原来是老朋友AES加密，加密代码一般长这样：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let f = CryptoJS.AES.encrypt(data, key, &#123;</span><br><span class="line">    &#x27;iv&#x27;: iv,</span><br><span class="line">    &#x27;mode&#x27;: CryptoJS.mode.CBC,</span><br><span class="line">    &#x27;padding&#x27;: CryptoJS.pad.ZeroPadding</span><br><span class="line">&#125;).toString();</span><br></pre></td></tr></table></figure></div>

<p>因此，只需要知道明文<code>data</code>，偏移量<code>iv</code>，密钥<code>key</code>，加密模式<code>mode</code>和<code>padding</code>模式就能算出密文</p>
<p>将混淆的代码函数片段拖入console中运行，逐步得到关键信息，将代码简化后可以得到：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function P(x) &#123;</span><br><span class="line">    const U = CryptoJS.enc.Utf8.parse(&#x27;y~.,ZaabH6Ri?L7*&#x27;);</span><br><span class="line">    const p = CryptoJS.enc.Utf8.parse(&#x27;koJ)KZhR1RW)!_~M&#x27;);</span><br><span class="line">    let f = CryptoJS.AES.encrypt(x, U, &#123;</span><br><span class="line">        &#x27;iv&#x27;: p,</span><br><span class="line">        &#x27;mode&#x27;: CryptoJS.mode.CBC,</span><br><span class="line">        &#x27;padding&#x27;: CryptoJS.pad.ZeroPadding</span><br><span class="line">    &#125;).toString();</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就一目了然了，以此即可复现整个问答流程</p>
<h2 id="脚本复现"><a href="#脚本复现" class="headerlink" title="脚本复现"></a>脚本复现</h2><p>有了加密方式，便尝试使用python复现该过程，</p>
<p>所需库：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">requests</span><br><span class="line">BeautifulSoup4</span><br><span class="line">pycryptodome</span><br></pre></td></tr></table></figure></div>

<p>完整代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=gbk</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prompt</span>(<span class="params">text</span>):</span><br><span class="line">    key = <span class="string">&quot;y~.,ZaabH6Ri?L7*&quot;</span>.zfill(<span class="number">16</span>).encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    iv = <span class="string">&quot;koJ)KZhR1RW)!_~M&quot;</span>.zfill(<span class="number">16</span>).encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    temp = <span class="string">b&quot;&quot;</span></span><br><span class="line">    data = text.encode()</span><br><span class="line">    data = data + <span class="string">&quot;\0&quot;</span>.encode() * (<span class="number">16</span> - <span class="built_in">len</span>(data) % <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">len</span>(data) / <span class="number">16</span>)):</span><br><span class="line">        block = data[<span class="number">16</span> * i: <span class="number">16</span> * (i + <span class="number">1</span>)]</span><br><span class="line">        b = cipher.encrypt(block)</span><br><span class="line">        temp += b</span><br><span class="line">    res = base64.b64encode(temp).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">pro, his</span>):</span><br><span class="line">    url = <span class="string">&quot;https://gpt.tool00.com/api/v1/chat/submit&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cookie&quot;</span>: <span class="string">&quot;_ga=GA1.1.800331461.1681885375; FCNEC=%5B%5B%22AKsRol9hmarvKjjCFyL8FNDRa4pULxPROMocI7VYSD0RbFdjyJTZC7l-bg8X9jiqb_sgT20JjKZUcByZcxCISeOtpn6yrS-MfP7fBKq_bnxmfgqatIjGyGj94fs7mzCuRdhlqjb3wptJRkxJW7PtMVyBrDHMULZplA%3D%3D%22%5D%2Cnull%2C%5B%5D%5D; __gads=ID=687486c546a2283f-22c4ae5397e0000b:T=1683182853:RT=1683182853:S=ALNI_MZCmtWOxQGyc3bhufEj8nnhyv6Pqg; __gpi=UID=00000c01738ff6e2:T=1683182853:RT=1683182853:S=ALNI_MZfy93-Hs1rY1R4PPrdQzg6CqPS3w; _ga_60RX9FESNC=GS1.1.1683187497.3.0.1683187497.0.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;https://gpt.tool00.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;referer&quot;</span>: <span class="string">&quot;https://gpt.tool00.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;prompt&quot;</span>: pro,</span><br><span class="line">        <span class="string">&quot;his&quot;</span>: his</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(url, headers=headers, data=json.dumps(data))</span><br><span class="line">    session = re.search(<span class="string">&quot;[0-9a-z]&#123;8&#125;-[0-9a-z]&#123;4&#125;-[0-9a-z]&#123;4&#125;-[0-9a-z]&#123;4&#125;-[0-9a-z]&#123;12&#125;&quot;</span>, r.headers[<span class="string">&quot;set-cookie&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> session.group()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stream</span>(<span class="params">session</span>):</span><br><span class="line">    url = <span class="string">&quot;https://gpt.tool00.com/api/v1/chat/stream&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,</span><br><span class="line">        <span class="string">&quot;accept-language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cache-control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cookie&quot;</span>: <span class="string">&quot;_ga=GA1.1.800331461.1681885375; FCNEC=%5B%5B%22AKsRol9hmarvKjjCFyL8FNDRa4pULxPROMocI7VYSD0RbFdjyJTZC7l-bg8X9jiqb_sgT20JjKZUcByZcxCISeOtpn6yrS-MfP7fBKq_bnxmfgqatIjGyGj94fs7mzCuRdhlqjb3wptJRkxJW7PtMVyBrDHMULZplA%3D%3D%22%5D%2Cnull%2C%5B%5D%5D; __gads=ID=687486c546a2283f-22c4ae5397e0000b:T=1683182853:RT=1683182853:S=ALNI_MZCmtWOxQGyc3bhufEj8nnhyv6Pqg; __gpi=UID=00000c01738ff6e2:T=1683182853:RT=1683182853:S=ALNI_MZfy93-Hs1rY1R4PPrdQzg6CqPS3w; _ga_60RX9FESNC=GS1.1.1683187497.3.0.1683187497.0.0.0; session=&quot;</span> + session,</span><br><span class="line">        <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;https://gpt.tool00.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;referer&quot;</span>: <span class="string">&quot;https://gpt.tool00.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.get(url, headers=headers)</span><br><span class="line">    b = bs(r.content, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">    extr = re.findall(<span class="string">&#x27;&quot;content&quot;: &quot;.*&quot;&#x27;</span>, <span class="built_in">str</span>(b))</span><br><span class="line">    ans = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(extr):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">1</span>:</span><br><span class="line">            ans += n[<span class="number">12</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt; &quot;</span> + ans.encode(<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>))</span><br><span class="line"></span><br><span class="line">history = []</span><br><span class="line"><span class="keyword">while</span> (text := <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt; &quot;</span>)):</span><br><span class="line">    <span class="keyword">if</span> text != <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">        stream(submit(prompt(text), history))</span><br><span class="line">        history.append(text)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
</search>
